% !TEX root = report.tex

\section{Part 1: Literature Research}

\subsection{Common Debugging Technologies}
\label{commondebugtech}

\subsubsection{System Observation}
\label{systemobservation}

The most basic debugging technique, apart from studying application code, is to observe the system in operation in order to come up with a hypothesis about the fault. The developer may make changes to application code (blinking LEDs, \textit{printf()} statements, etc) and re-run the application in order to gain more information about the system state and execution flow.

While many developers may believe that this technique is superseded by symbolic debugging in most cases, this technique is still widely used \todo{ref?}.

\subsubsection{Symbolic Debuggers}
\label{symbolicdebug}

Symbolic debuggers are widely used, crucial tools in software debugging. They have access to information about symbols used in the application code, such as variable and function names, and their relationship to the application binary. Also, in general they are able to control execution flow of running applications and inspect or alter the state of the system, for example by accessing memory and registers. This combination of features makes them into versatile tools to track down the root causes of bugs and fix them in the application code.

However, multiple problems are associated with symbolic debugging, some specific to embedded systems. One of them is the ``probe effect'': in general, execution of the binary while debugging symbolically is not behaviourally identical to executing the binary normally. This may lead to difficulties in reproducing the fault or give inaccurate information about its cause(s). Arguably this is especially problematic in embedded systems, where correct execution tends to rely more on correct timing of hardware inputs and outputs.
Another problem is the resource overhead imposed by symbolic debugging. The resources required to run a symbolic debugger are not always available in embedded systems, prompting the use of techniques to debug an application remotely from a host system \todo{refer to section}.

 in some shape or form, have existed ever since debugging information could be graphically displayed (en.wikipedia.org/wiki/Debug\_symbol). Modern debuggers typically support advanced features such as conditional breakpoints, ........
 
 Regardless of the drawbacks of symbolic debugging, it is \todo{probably} still the most widely-used debugging technique for software engineers, embedded or not.

\subsection{Emerging Debugging Technologies}
\label{emergingtechnologies}
\subsubsection{Back-in-time Debugging}
\label{backintime}
\subsubsection{Automatic Fault Localization}
\label{autofault}

\subsection{Debugging of Embedded Systems}
\label{debugembedded}

\subsubsection{Remote Symbolic Debugging}
\label{debugembeddedsymbolic}

As described in section \ref{symbolicdebug}, symbolic debugging on embedded systems amplifies the problems of ``probe effect'' and debugging overhead. It has become commonplace to debug embedded systems remotely from a host system, in order to make the necessary resources available and to debug with minimal overhead on the embedded device itself.

In order to perform symbolic debugging remotely, the debugger, running on the host system, must have similar access to the embedded system's state as it would when debugging  an application on the host system. Therefore, some kind of interface is required between host and target. An example of such an interface is the \todo{official name} JTAG standard \todo{ref to section}.

In many cases, a debug adapter is needed to bridge the debugging interface to whatever interface the host supports, such as USB or a serial port.

The embedded target device must also provide a certain level of access to its internals via the interface, in order for the symbolic debugger to be able to inspect its state and control execution flow. Typical modern embedded processors have various levels of provisions for this, which may include halt/continue/step/reset control and read/write access to registers and/or memory through the debugging interface.

All in all, this makes remote symbolic debugging a similar experience to regular symbolic debugging, although the addition of a communications interface in-between tends to result in extra performance overhead.

\subsubsection{Device-specific Debugging Features}

In order to alleviate some of the drawbacks of remote symbolic debugging, embedded devices and/or processors may incorporate extra features which are useful for debugging. An example is the ARM Cortex-M family of embedded processors, which (optionally) include the following features:

\begin{itemize}
\item Access to system exception state
\item Hardware break-/watchpoints
\item Dedicated hardware for patching/remapping parts of code memory
\item Run-time non-intrusive profiling
\item Instruction tracing
\end{itemize}

More information about these features will be given in the final internship report.

\subsection{The Practice of Debugging}
\label{debuggingpractice}

The practice of debugging in general has been studied thoroughly over the last few decades. Several relatively recent studies \todo{references} give overviews of how debugging has evolved, highlighting the advancement of debugging tools and technology, but also investigating the experiences of software engineers in order to assess the amount of improvement these technologies have actually achieved.

Among other things, \cite{debugging_practice} investigates whether recent debugging technologies such as back-in-time debugging and automatic fault localization have made any difference in the daily debugging practices of engineers. While only several developers were interviewed for this study, an interesting result was that none of them had heard of either of these technologies before.
